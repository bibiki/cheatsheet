package com.cheatsheets.clojure;

import picocli.CommandLine.Command;

@Command(name = "transducers")
public class Transducers implements Runnable {

	@Override
	public void run() {
		System.out.println("run 'cheatsheet clojure transducers -h' to see subcommands to transducers");
	}
	
	@Command(name = "map")
	public void map() {
		
	}
	
	@Command(name = "mapcat")
	public void mapcat() {
		
	}
	
	@Command(name = "filter")
	public void filter() {
		
	}
	
	@Command(name = "remove")
	public void remove() {
		
	}
	
	@Command(name = "take")
	public void take() {
		
	}
	
	@Command(name = "take-while")
	public void takeWhile() {
		System.out.println("take-while");
	}
	
	@Command(name = "take-nth")
	public void takeNth() {
		
	}
	
	@Command(name = "drop")
	public void drop() {
		
	}
	
	@Command(name = "drop-while")
	public void dropWhile() {
		
	}
	
	@Command(name = "replace")
	public void replace() {
		
	}
	
	@Command(name = "partition-by")
	public void partitionBy() {
		
	}
	
	@Command(name = "partition-all")
	public void partitionAll() {
		
	}
	
	@Command(name = "keep")
	public void keep() {
		
	}
	
	@Command(name = "keep-indexed")
	public void keepIndexed() {
		
	}
	
	@Command(name = "map-indexed")
	public void mapIndexed() {
		
	}
	
	@Command(name = "distinct")
	public void distinct() {
		
	}
	
	@Command(name = "interpose")
	public void interpose() {
		
	}
	
	@Command(name = "cat")
	public void cat() {
		
	}
	
	@Command(name = "dedupe")
	public void dedupe() {
		
	}
	
	@Command(name = "random-sample")
	public void randomSample() {
		
	}
	
	@Command(name = "halt-when")
	public void haltWhen() {
		
	}
}
